const server = require('../../../test-utils/index')
const chai = require('chai')
const expect = chai.expect
chai.use(require('chai-http'))

const userA = require('./mockObjects.org').userA
const userB = require('./mockObjects.org').userB
const userC = require('./mockObjects.org').userC
const userAHeader = require('./mockObjects.org').userAHeader
const userDHeader = require('./mockObjects.org').userDHeader
const secretariatHeader = require('./mockObjects.org').secretariatHeader
const owningOrgHeader = require('./mockObjects.org').owningOrgHeader
const orgHeader = require('./mockObjects.org').orgHeader
const existentUser = require('./mockObjects.org').existentUser
const nonExistentUser = require('./mockObjects.org').nonExistentUser
const existentOrg = require('./mockObjects.org').existentOrg
const owningOrg = require('./mockObjects.org').owningOrg
const existentUserDummy = require('./mockObjects.org').existentUserDummy
const existentOrgDummy = require('./mockObjects.org').existentOrgDummy
const nonExistentOrg = require('./mockObjects.org').nonExistentOrg

const errors = require('../../../src/controller/org.controller/error')
const error = new errors.OrgControllerError()

describe('Test user functions in Org Controller', () => {
  context('Creating a user', () => {
    it('User is not created because org does not exist', (done) => {
      chai.request(server)
        .post(`/user-not-created-org-does-not-exist/${nonExistentOrg.short_name}`)
        .set(secretariatHeader)
        .send(nonExistentUser)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          expect(res).to.have.status(404)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.orgDneParam(nonExistentOrg.short_name)
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)
          done()
        })
    })

    it('Param org\'s UUID does not match the provided org\'s UUID', (done) => {
      const testUser = Object.assign({}, existentUser)
      testUser.org_UUID = owningOrg.UUID

      chai.request(server)
        .post(`/user-not-created-org-does-not-match/${existentOrg.short_name}`)
        .set(secretariatHeader)
        .send(testUser)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          expect(res).to.have.status(400)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.shortnameMismatch(existentOrg.short_name, owningOrg.short_name)
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)
          done()
        })
    })

    it('User is created when org UUID is undefined', (done) => {
      const testUser = Object.assign({}, nonExistentUser)
      delete testUser.org_UUID

      chai.request(server)
        .post(`/user-created-org-undefined/${existentOrg.short_name}`)
        .set(secretariatHeader)
        .send(testUser)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          expect(res).to.have.status(200)
          expect(res).to.have.property('body').and.to.be.a('object')
          expect(res.body).to.have.property('message').and.to.be.a('string')
          expect(res.body.message).to.equal(testUser.username + ' was successfully created.')
          expect(res.body).to.have.property('created').and.to.be.a('object')
          expect(res.body.created).to.have.property('org_UUID').and.to.equal(existentOrg.UUID)
          expect(res.body.created).to.have.property('username').and.to.equal(testUser.username)
          done()
        })
    })

    it('User is created when org UUID is null', (done) => {
      const testUser = Object.assign({}, nonExistentUser)
      testUser.org_UUID = null

      chai.request(server)
        .post(`/user-created-org-null/${existentOrg.short_name}`)
        .set(secretariatHeader)
        .send(testUser)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          expect(res).to.have.status(200)
          expect(res).to.have.property('body').and.to.be.a('object')
          expect(res.body).to.have.property('message').and.to.be.a('string')
          expect(res.body.message).to.equal(testUser.username + ' was successfully created.')
          expect(res.body).to.have.property('created').and.to.be.a('object')
          expect(res.body.created).to.have.property('org_UUID').and.to.equal(existentOrg.UUID)
          expect(res.body.created).to.have.property('username').and.to.equal(testUser.username)
          done()
        })
    })

    it('User is created when user UUID is undefined', (done) => {
      const testUser = Object.assign({}, nonExistentUser)
      delete testUser.UUID

      chai.request(server)
        .post(`/user-created-uuid-undefined/${existentOrg.short_name}`)
        .set(secretariatHeader)
        .send(testUser)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          expect(res).to.have.status(200)
          expect(res).to.have.property('body').and.to.be.a('object')
          expect(res.body).to.have.property('message').and.to.be.a('string')
          expect(res.body.message).to.equal(testUser.username + ' was successfully created.')
          expect(res.body).to.have.property('created').and.to.be.a('object')
          expect(res.body.created).to.have.property('org_UUID').and.to.equal(testUser.org_UUID)
          expect(res.body.created).to.have.property('username').and.to.equal(testUser.username)
          expect(res.body.created).to.have.property('UUID').and.to.be.a('string')
          done()
        })
    })

    it('User is created when UUID is null', (done) => {
      const testUser = Object.assign({}, nonExistentUser)
      testUser.UUID = null

      chai.request(server)
        .post(`/user-created-uuid-null/${existentOrg.short_name}`)
        .set(secretariatHeader)
        .send(testUser)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          expect(res).to.have.status(200)
          expect(res).to.have.property('body').and.to.be.a('object')
          expect(res.body).to.have.property('message').and.to.be.a('string')
          expect(res.body.message).to.equal(testUser.username + ' was successfully created.')
          expect(res.body).to.have.property('created').and.to.be.a('object')
          expect(res.body.created).to.have.property('org_UUID').and.to.equal(testUser.org_UUID)
          expect(res.body.created).to.have.property('username').and.to.equal(testUser.username)
          expect(res.body.created).to.have.property('UUID').and.to.be.a('string')
          done()
        })
    })

    it('User is created when UUID is defined', (done) => {
      chai.request(server)
        .post(`/user-created-uuid-defined/${existentOrg.short_name}`)
        .set(secretariatHeader)
        .send(nonExistentUser)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          expect(res).to.have.status(200)
          expect(res).to.have.property('body').and.to.be.a('object')
          expect(res.body).to.have.property('message').and.to.be.a('string')
          expect(res.body.message).to.equal(nonExistentUser.username + ' was successfully created.')
          expect(res.body).to.have.property('created').and.to.be.a('object')
          expect(res.body.created).to.have.property('org_UUID').and.to.equal(nonExistentUser.org_UUID)
          expect(res.body.created).to.have.property('username').and.to.equal(nonExistentUser.username)
          expect(res.body.created).to.have.property('UUID').and.to.equal(nonExistentUser.UUID)
          done()
        })
    })

    it('User is not created because it already exists', (done) => {
      chai.request(server)
        .post(`/user-not-created-already-exists/${existentOrg.short_name}`)
        .set(secretariatHeader)
        .send(existentUser)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          expect(res).to.have.status(400)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.userExists(existentUser.username)
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)
          done()
        })
    })
  })

  context('Updating a user', () => {
    it('User is not updated because org does not exist', (done) => {
      const shortname = nonExistentOrg.short_name.replace(/\s/g, '')
      const username = existentUser.username.replace(/\s/g, '')
      chai.request(server)
        .post(`/user-not-updated-org-doesnt-exist/${shortname}/${username}`)
        .set(secretariatHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          expect(res).to.have.status(404)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.orgDneParam(nonExistentOrg.short_name)
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)
          done()
        })
    })

    it('User is not updated because user does not exist', (done) => {
      const shortname = existentOrg.short_name.replace(/\s/g, '')
      const username = nonExistentUser.username.replace(/\s/g, '')
      chai.request(server)
        .post(`/user-not-updated-doesnt-exist/${shortname}/${username}`)
        .set(secretariatHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          expect(res).to.have.status(404)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.userDne(nonExistentUser.username)
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)
          done()
        })
    })

    it('User is not updated because the new shortname does not exist', (done) => {
      chai.request(server)
        .post(`/user-not-updated-user-doesnt-exist/${existentOrg.short_name}/${existentUser.username}?org_shortname=${nonExistentOrg.short_name}`)
        .set(secretariatHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          expect(res).to.have.status(404)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.orgDne(nonExistentOrg.short_name)
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)
          done()
        })
    })

    // check that the user is unchanged
    it('No query parameters are provided', async () => {
      const result = existentUser

      const res = await chai.request(server)
        .post(`/user-not-updated-no-parameters/${existentOrg.short_name}/${existentUser.username}`)
        .set(secretariatHeader)

      expect(res).to.have.status(200)
      expect(res).to.have.property('body').and.to.be.a('object')
      expect(res.body).to.have.property('updated').and.to.be.a('object')
      expect(res.body.updated.authority.active_roles[0]).to.equal(existentUser.authority.active_roles[0])
      expect(result.cna_short_name).to.equal(existentUser.cna_short_name)
      expect(result.username).to.equal(existentUser.username)
      expect(result.UUID).to.equal(existentUser.UUID)
      expect(result.secret).to.equal(existentUser.secret)
      expect(result.active).to.equal(existentUser.active)
      expect(result.name.first).to.equal(existentUser.name.first)
      expect(result.name.last).to.equal(existentUser.name.last)
      expect(result.name.middle).to.equal(existentUser.name.middle)
      expect(result.name.suffix).to.equal(existentUser.name.suffix)
      expect(result.name.surname).to.equal(existentUser.name.surname)
    })
  })

  context('Resetting a user\'s secret', () => {
    it('User secret is not reset because org does not exists', (done) => {
      chai.request(server)
        .post(`/user-secret-not-reset-org-doesnt-exist/${nonExistentOrg.short_name}/${existentUser.username}`)
        .set(secretariatHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          expect(res).to.have.status(404)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.orgDneParam(nonExistentOrg.short_name)
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)
          done()
        })
    })

    it('User secret is not reset because user does not exists', (done) => {
      chai.request(server)
        .post(`/user-secret-not-reset-user-doesnt-exist/${existentOrg.short_name}/${nonExistentUser.username}`)
        .set(secretariatHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          expect(res).to.have.status(404)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.userDne(nonExistentUser.username)
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)
          done()
        })
    })

    it('Requester is from same org but has different username: User secret is not reset because requester is not the same user or is the secretariat or org admin', (done) => {
      chai.request(server)
        .post(`/user-secret-reset-sameOrg/${existentOrgDummy.short_name}/${userC.username}`) // requester has same org as user but different username
        .set(userAHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          expect(res).to.have.status(403)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.notSameUserOrSecretariat()
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)
          done()
        })
    })

    it('Requester has same username but is from different org: User secret is not reset because requester is not the same user or is the secretariat or org admin', (done) => {
      chai.request(server)
        .post(`/user-secret-reset-sameUsername/${owningOrg.short_name}/${userB.username}`) // requester has same username as user but different org
        .set(userAHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          expect(res).to.have.status(403)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.notSameUserOrSecretariat()
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)
          done()
        })
    })

    it('Secret is reset because requester is a secretariat', (done) => {
      chai.request(server)
        .post(`/user-secret-reset-secretariat/${existentOrg.short_name}/${existentUser.username}`)
        .set(secretariatHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          expect(res).to.have.status(200)
          expect(res).to.have.property('body').and.to.be.a('object')
          expect(res.body).to.have.property('API-secret').and.to.be.a('string')
          done()
        })
    })

    it('Secret is reset because requester is the user', (done) => {
      chai.request(server)
        .post(`/user-secret-reset-notSameOrgOrSecretariat/${existentOrgDummy.short_name}/${userA.username}`)
        .set(userAHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          expect(res).to.have.status(200)
          expect(res).to.have.property('body').and.to.be.a('object')
          expect(res.body).to.have.property('API-secret').and.to.be.a('string')
          done()
        })
    })

    it('Secret is not reset because requester is org admin but not for designated org', (done) => {
      chai.request(server)
        .post(`/user-secret-not-reset-userIsOrgAdminForDifferentOrg/${owningOrg.short_name}/${userB.username}`)
        .set(userDHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          expect(res).to.have.status(403)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.notSameUserOrSecretariat()
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)
          done()
        })
    })

    it('Secret is reset because requester is the org admin', (done) => {
      chai.request(server)
        .post(`/user-secret-reset-userIsOrgAdmin/${existentOrgDummy.short_name}/${userC.username}`)
        .set(userDHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }
          expect(res).to.have.status(200)
          expect(res).to.have.property('body').and.to.be.a('object')
          expect(res.body).to.have.property('API-secret').and.to.be.a('string')
          done()
        })
    })
  })

  context('Getting a user', () => {
    it('Org does not exists', (done) => {
      chai.request(server)
        .get(`/user-get-user-org-doesnt-exist/${nonExistentOrg.short_name}/${existentUser.username}`)
        .set(secretariatHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          expect(res).to.have.status(404)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.orgDneParam(nonExistentOrg.short_name)
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)
          done()
        })
    })

    it('User does not exists', (done) => {
      chai.request(server)
        .get(`/user-get-user-user-doesnt-exist/${existentOrg.short_name}/${nonExistentUser.username}`)
        .set(secretariatHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          expect(res).to.have.status(404)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.userDne(nonExistentUser.username)
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)
          done()
        })
    })

    it('User exists and the requester is the secretariat', (done) => {
      chai.request(server)
        .get(`/user-get-user/${existentOrg.short_name}/${existentUser.username}`)
        .set(secretariatHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          expect(res).to.have.status(200)
          expect(res).to.have.property('body').and.to.be.a('object')
          expect(res.body).to.have.property('username').and.to.equal(existentUser.username)
          expect(res.body).to.have.property('org_UUID').and.to.equal(existentUser.org_UUID)
          done()
        })
    })

    it('User exists and the requester belongs to the user\'s org', (done) => {
      chai.request(server)
        .get(`/user-get-user/${owningOrg.short_name}/${existentUserDummy.username}`)
        .set(owningOrgHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          expect(res).to.have.status(200)
          expect(res).to.have.property('body').and.to.be.a('object')
          expect(res.body).to.have.property('username').and.to.equal(existentUserDummy.username)
          expect(res.body).to.have.property('org_UUID').and.to.equal(existentUserDummy.org_UUID)
          done()
        })
    })

    it('User exists and the requester is not secretariat and does not belong to the user\'s org', (done) => {
      chai.request(server)
        .get(`/user-get-user/${owningOrg.short_name}/${existentUserDummy.username}`)
        .set(orgHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          expect(res).to.have.status(403)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.notSameOrgOrSecretariat()
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)
          done()
        })
    })
  })
})
