const server = require('../../../test-utils/index')
const chai = require('chai')
const expect = chai.expect
chai.use(require('chai-http'))
const userAHeader = require('./mockObjects.non-sequential').userAHeader
const userBHeader = require('./mockObjects.non-sequential').userBHeader
const orgA = require('./mockObjects.non-sequential').orgA
const orgB = require('./mockObjects.non-sequential').orgB
const userA = require('./mockObjects.non-sequential').userA
const userB = require('./mockObjects.non-sequential').userB
const year = require('./mockObjects.non-sequential').year
const errors = require('../../../src/controller/cve-id.controller/error')
const error = new errors.CveIdControllerError()
const testRepo = require('../../../test-utils/repositories')
const cveIdTestRepoAB1 = new testRepo.CveIdReservePoolIncremented10IdsCaseAB1()
const cveIdRangeTestRepoAB1 = new testRepo.CveIdRangeReserveNonSequentialSuccessCaseAB1()
const cveIdTestRepoAB2 = new testRepo.CveIdReservePoolIncremented10IdsCaseAB2()
const cveIdRangeTestRepoAB2 = new testRepo.CveIdRangeReserveNonSequentialSuccessCaseAB2()
const idsA = []
const idsB = []

describe('Test ID Reservator for Non-Sequential Interleaving Case', () => {
  context('Interleaving reservation between User A and User B', () => {
    it('User A reserves 10 ids', (done) => {
      chai.request(server)
        .post(`/cve-id-reserve-user-a-10-ids?short_name=${orgA.short_name}&cve_year=${year}&amount=10&batch_type=non-sequential`) // 5
        .set(userAHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          const quotaHeader = (orgA.policies.id_quota - 10).toString()
          expect(res.header).to.have.property('cve-api-remaining-quota').and.to.equal(quotaHeader)

          expect(res).to.have.status(200)
          expect(res).to.have.property('body').and.to.be.a('object')
          expect(res.body).to.have.property('cve_ids').and.to.be.a('array').and.to.have.lengthOf(10)

          // check that the reserved cve ids were reserved by userA
          res.body.cve_ids.forEach(obj => {
            idsA.push(obj.cve_id)
            const index = parseInt(obj.cve_id.match(/\d+$/g))
            expect(index).to.be.greaterThan(0).and.lessThan(26) // Available id range: CVE-YYYY-20001 to CVE-YYYY-20025
            expect(obj).to.have.property('state').and.to.equal('RESERVED') // checking that all CVE IDs returned are RESERVED
            expect(obj).to.have.property('owning_cna').and.to.equal(orgA.short_name)
            expect(obj).to.have.nested.property('requested_by.cna').and.to.equal(orgA.short_name)
            expect(obj).to.have.nested.property('requested_by.user').and.to.equal(userA.username)
          })

          // check that no duplicate cve ids were reserved
          res.body.cve_ids.forEach(id1 => {
            let counter = 0
            res.body.cve_ids.forEach(id2 => {
              if (id1 === id2) {
                counter++
              }
            })
            expect(counter).to.equal(1)
          })

          // check total count of reserved ids by userA
          const docs = cveIdTestRepoAB1.getCveIdDocuments()
          let reservedCounter = 0
          docs.forEach(doc => {
            if (doc.owning_cna === orgA.UUID && doc.cve_year === year && doc.state === 'RESERVED') {
              reservedCounter++
            }
          })
          expect(reservedCounter).to.equal(10)

          // check count of available ids
          let availableCounter = 0
          docs.forEach(doc => {
            if (doc.cve_year === year && doc.state === 'AVAILABLE') {
              availableCounter++
            }
          })
          expect(availableCounter).to.equal(15)

          // check that unreserved ids by userA are available
          const rangeDoc = cveIdRangeTestRepoAB1.getCveIdRange()
          const topId = rangeDoc.ranges.general.top_id
          const availableDocs = []
          for (let i = 0; i < docs.length; i++) {
            let contains = false
            for (let j = 0; j < idsA.length; j++) {
              if (docs[i].cve_id === idsA[j] && docs[i].cve_year === year) {
                contains = true
                break
              }
            }
            if (!contains) {
              availableDocs.push(docs[i])
            }
          }
          expect(availableDocs).to.have.lengthOf(15)
          availableDocs.forEach(obj => {
            const index = parseInt(obj.cve_id.match(/\d+$/g))
            expect(index).to.be.lessThan(topId + 1) // check that the id is less than the current top id
            expect(obj).to.have.property('state').and.to.equal('AVAILABLE')
            expect(obj).to.have.property('owning_cna').and.to.equal('N/A')
            expect(obj).to.have.nested.property('requested_by.cna').and.to.equal('N/A')
            expect(obj).to.have.nested.property('requested_by.user').and.to.equal('N/A')
          })

          done()
        })
    })

    it('User B reserves 10 ids', (done) => {
      chai.request(server)
        .post(`/cve-id-reserve-user-b-10-ids?short_name=${orgB.short_name}&cve_year=${year}&amount=10&batch_type=non-sequential`) // 20
        .set(userBHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          const quotaHeader = (orgB.policies.id_quota - 10).toString()
          expect(res.header).to.have.property('cve-api-remaining-quota').and.to.equal(quotaHeader)

          expect(res).to.have.status(200)
          expect(res).to.have.property('body').and.to.be.a('object')
          expect(res.body).to.have.property('cve_ids').and.to.be.a('array').and.to.have.lengthOf(10)

          // check that the reserved cve ids were reserved by userB
          res.body.cve_ids.forEach(obj => {
            idsB.push(obj.cve_id)
            const index = parseInt(obj.cve_id.match(/\d+$/g))
            expect(index).to.be.greaterThan(0).and.lessThan(26) // Available id range: CVE-YYYY-0001 to CVE-YYYY-0025
            expect(obj).to.have.property('state').and.to.equal('RESERVED') // checking that all CVE IDs returned are RESERVED
            expect(obj).to.have.property('owning_cna').and.to.equal(orgB.short_name)
            expect(obj).to.have.nested.property('requested_by.cna').and.to.equal(orgB.short_name)
            expect(obj).to.have.nested.property('requested_by.user').and.to.equal(userB.username)
          })

          // check that no duplicate cve ids were reserved
          res.body.cve_ids.forEach(id1 => {
            let counter = 0
            res.body.cve_ids.forEach(id2 => {
              if (id1 === id2) {
                counter++
              }
            })
            expect(counter).to.equal(1)
          })

          // check total count of reserved ids by userB
          const docs = cveIdTestRepoAB2.getCveIdDocuments()
          let reservedCounter = 0
          docs.forEach(doc => {
            if (doc.owning_cna === orgB.UUID && doc.cve_year === year && doc.state === 'RESERVED') {
              reservedCounter++
            }
          })
          expect(reservedCounter).to.equal(10)

          // check count of available ids
          let availableCounter = 0
          docs.forEach(doc => {
            if (doc.cve_year === year && doc.state === 'AVAILABLE') {
              availableCounter++
            }
          })
          expect(availableCounter).to.equal(5)

          // check that unreserved ids by userA or userB are available
          const rangeDoc = cveIdRangeTestRepoAB2.getCveIdRange()
          const topId = rangeDoc.ranges.general.top_id
          const availableDocs = []
          for (let i = 0; i < docs.length; i++) {
            let contains = false
            for (let j = 0; j < idsA.length; j++) {
              if (docs[i].cve_id === idsA[j] && docs[i].cve_year === year) {
                contains = true
                break
              }
            }

            if (!contains) {
              for (let j = 0; j < idsB.length; j++) {
                if (docs[i].cve_id === idsB[j] && docs[i].cve_year === year) {
                  contains = true
                  break
                }
              }
            }

            if (!contains) {
              availableDocs.push(docs[i])
            }
          }
          expect(availableDocs).to.have.lengthOf(5)
          availableDocs.forEach(obj => {
            const index = parseInt(obj.cve_id.match(/\d+$/g))
            expect(index).to.be.lessThan(topId + 1) // check that the id is less than the current top id
            expect(obj).to.have.property('state').and.to.equal('AVAILABLE')
            expect(obj).to.have.property('owning_cna').and.to.equal('N/A')
            expect(obj).to.have.nested.property('requested_by.cna').and.to.equal('N/A')
            expect(obj).to.have.nested.property('requested_by.user').and.to.equal('N/A')
          })

          done()
        })
    })

    it(`User A tries to reserve 10 more ids but the CveId Range document for year ${year} is full`, (done) => {
      chai.request(server)
        .post(`/cve-id-reserve-user-a-10-ids-year-full?short_name=${orgA.short_name}&cve_year=${year}&amount=10&batch_type=non-sequential`)
        .set(userAHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          const quotaHeader = (orgA.policies.id_quota - 10).toString()
          expect(res.header).to.have.property('cve-api-remaining-quota').and.to.equal(quotaHeader)

          expect(res).to.have.status(403)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.yearRangeFull(year)
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)

          // check that no duplicate cve ids were reserved by userA and userB
          idsA.forEach(id1 => {
            let isDisjoint = true
            idsB.forEach(id2 => {
              if (id1 === id2) {
                isDisjoint = false
              }
            })
            expect(isDisjoint).to.equal(true) // pass: The intersection set between idsA and idsB is null
          })

          done()
        })
    })
  })
})
