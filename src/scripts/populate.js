/*
 * used to populate or re-populate a MongoDB-compatible document
 * database with static fixtures at `cve-services/datadump/pre-population`
 */

const express = require('express')
const config = require('config')
const mongoose = require('mongoose')
const uuid = require('uuid')
const app = express()
const logger = require('../middleware/logger')
const CveIdRange = require('../model/cve-id-range')
const CveId = require('../model/cve-id')
const Cve = require('../model/cve')
const Org = require('../model/org')
const User = require('../model/user')
const argon2 = require('argon2')
const cryptoRandomString = require('crypto-random-string')
const CONSTANTS = require('../constants')
const utils = require('../utils/utils')
const fs = require('fs')
const JSONStream = require('JSONStream')
const util = require('util')
const errors = require('../utils/error')
const error = new errors.IDRError()
const apiKeyFile = 'user-secret.txt'
require('dotenv').config() // This enables us to read from the .env file.

const populateTheseCollections = {
  'Cve': Cve,
  'Cve-Id-Range': CveIdRange,
  'Cve-Id': CveId,
  'User': User,
  'Org': Org
}

// Body Parser Middleware
app.use(express.json()) // Allows us to handle raw JSON data
app.use(express.urlencoded({ extended: false })) // Allows us to handle url encoded data
// Make mongoose connection available globally
global.mongoose = mongoose

// construct MongoDB connection string
// assumes that host, port, database are always defined in default config, but
// that username and password may not be
const appEnv = process.env.NODE_ENV
let dbUser, dbPassword

if (process.env.MONGO_USER && process.env.MONGO_PASSWORD) {
  dbUser = process.env.MONGO_USER
  dbPassword = process.env.MONGO_PASSWORD
} else {
  dbUser = config.has(`${appEnv}.username`) ? config.get(`${appEnv}.username`) : false
  dbPassword = config.has(`${appEnv}.password`) ? config.get(`${appEnv}.password`) : false
}

const dbHost = process.env.MONGO_HOST ? process.env.MONGO_HOST : config.get(`${appEnv}.host`)
const dbPort = process.env.MONGO_PORT ? process.env.MONGO_PORT : config.get(`${appEnv}.port`)
const dbName = config.get(`${appEnv}.database`)
const dbLoginPrepend = (dbUser && dbPassword) ? `${dbUser}:${dbPassword}@` : ''
const dbConnectionStr = `mongodb://${dbLoginPrepend}${dbHost}:${dbPort}/${dbName}`

// Connect to MongoDB database
mongoose.connect(dbConnectionStr, {
  useNewUrlParser: true,
  useUnifiedTopology: false,
  useFindAndModify: false
})

const db = mongoose.connection

db.on('error', () => {
  console.error.bind(console, 'Connection Error: Something went wrong!')
  logger.error(error.connectionError())
})

db.once('open', async () => {
  logger.info(`Successfully connected to database ${dbName} at ${dbHost}:${dbPort}`)

  // Ask user to confirm pre-population
  // This will prep MongoDB by removing the Cve, Cve-Id-Range, Cve-Id,
  // Org, and User collections
  /*const prompt = require('prompt-sync')({ sigint: true })
  let userInput = prompt(
    `Are you sure you wish to pre-populate the database for the ${appEnv} environment? ` +
    "Doing so will drop the 'Cve', 'Cve-Id-Range', 'Cve-Id', 'Org' and 'User' collections " +
    `in the ${dbName} database. (y/n) `
  )
  while (userInput.toLowerCase() !== 'n' && userInput.toLowerCase() !== 'y') {
    console.log('Unrecognized Input')
    userInput = prompt(
      `Do you wish to pre-populate the database for the ${appEnv} environment? ` +
      "Doing so will drop the 'Cve', 'Cve-Id-Range', 'Cve-Id', 'Org' and 'User' collections " +
      `in the ${dbName} database. (y/n) `
    )
  }*/
  let userInput = 'y'

  // drops and re-populates collections
  if (userInput.toLowerCase() === 'y') {
    let names = []
    let collections = await db.db.listCollections().toArray()
    collections.forEach(collection => {
      names.push(collection.name)
    })

    
    for (const name in populateTheseCollections) {
      if (names.includes(name)) {
        logger.info(`Dropping ${name} collection !!!`)
        await db.dropCollection(name)
      }
    }

    names = []
    collections = await db.db.listCollections().toArray()
    collections.forEach(collection => {
      names.push(collection.name)
    })

    // TODO: need to populate org, user, cve-id in that order given UUID links

    if (!names.includes('Cve-Id-Range') && !names.includes('Cve-Id') && !names.includes('Cve') && !names.includes('Org') && !names.includes('User')) {
      // Org
      await populateCollection(
        './datadump/pre-population/orgs.json',
        Org, newOrgTransform
      )

      // User, depends on Org
      const hash = await preprocessUserSecrets()
      await populateCollection(
        './datadump/pre-population/users.json',
        User, newUserTransform, hash
      )

      let populatePromises = []

      // CVE ID Range
      populatePromises.push(populateCollection(
        './datadump/pre-population/cve-ids-range.json',
        CveIdRange
      ))

      // CVE
      populatePromises.push(populateCollection(
        './datadump/pre-population/cves.json',
        Cve
      ))

      // CVE ID, depends on User and Org
      populatePromises.push(populateCollection(
        './datadump/pre-population/cve-ids.json',
        CveId, newCveIdTransform
      ))

      // don't close database connection until all remaining populate
      // promises are resolved
      Promise.all(populatePromises).then(function () {
        logger.info('Successfully populated the database!')
        mongoose.connection.close()
      })
    } else {
      logger.error(
        'The database was not populated because ' +
        'some of the collections were not deleted.')
    }
  }
})

async function preprocessUserSecrets () {
  const color = require('kleur')

  if (process.env.NODE_ENV === 'development') {
    const secretKey = process.env.LOCAL_KEY
    const hash = await argon2.hash(secretKey)

    // provide secret to user in development
    console.log(color.bold().black().bgWhite(
      'Use the following API secret for all users:') + ' ' +
      color.bold().black().italic().bgGreen(secretKey)
    )

    return hash
  } else {
    // delete file for user secrets if one already exists
    fs.unlink(apiKeyFile, err => {
      if (err && err.code !== 'ENOENT') {
        logger.error(error.fileDeleteError(err))
        mongoose.connection.close()
      }
    })

    console.log(
      color.bold().black().bgWhite('The users\' API secret can be found in:') + ' ' +
      color.bold().black().italic().bgGreen(apiKeyFile)
    )
  }
}

async function newOrgTransform (org) {
  org.UUID = uuid.v4()
  org.inUse = false
  return org
}

async function newUserTransform (user, hash) {
  const tmpOrgUUID = await utils.getOrgUUID(user.cna_short_name)
  user.org_UUID = tmpOrgUUID
  user.UUID = uuid.v4()
  user.authority = { active_roles: [] }

  // shared secret key in development environments
  if (process.env.NODE_ENV === 'development') {
    user.secret = hash
  } else {
    const randomKey = cryptoRandomString({ length: CONSTANTS.CRYPTO_RANDOM_STRING_LENGTH })
    user.secret = await argon2.hash(randomKey)

    // write each user's API key to file
    // necessary when standing up any new shared instance of the system
    const payload = { username: user.username, secret: randomKey }
    fs.writeFile(apiKeyFile, JSON.stringify(payload) + '\n', { flag: 'a' }, (err) => {
      if (err) {
        logger.error(error.fileWriteError(err))
        mongoose.connection.close()
      }
    })
  }

  return user
}

async function newCveIdTransform (cveId) {
  const tmpRequestingCnaUUID = await utils.getOrgUUID(cveId.requested_by.cna)
  const tmpOwningCnaUUID = await utils.getOrgUUID(cveId.owning_cna)
  const tmpUserUUID = await utils.getUserUUID(cveId.requested_by.user, tmpRequestingCnaUUID)
  cveId.requested_by.cna = tmpRequestingCnaUUID
  cveId.owning_cna = tmpOwningCnaUUID
  cveId.requested_by.user = tmpUserUUID
  return cveId
}

/* populates any collection given the file path for an input JSON,
 * the data model for the collection, a function that transforms the
 * data, and a hash that only gets use in the User collection
 */ 
function populateCollection (filePath, dataModel, dataTransform = async function (x) {return x}, hash) {
  const dataName = dataModel.collection.collectionName
  logger.info(`Populating ${dataName} collection...`)
  return new Promise(function (resolve, reject) {
    // let batchData = []
    let promises = []
    fs.createReadStream(filePath, {encoding: 'utf8'})
      .pipe(JSONStream.parse('*'))
      .on('data', async function (data) {
        this.pause()
        data = await dataTransform(data, hash)
        promises.push(dataModel.insertMany(data))
        this.resume()
        promisesShifter(promises)
      })
      .on('close', function () {
        Promise.all(promises).then(function () {
          logger.info(`${dataName} populated!`)
          resolve()
        })
      })
      .on('error', reject)
  })
}

function promisesShifter (promises) {
  if (promises) {
    while (!util.inspect(promises[0]).includes('pending')) {
      promises.shift()
      if (promises.length == 0) { break }
    }
  }
}
