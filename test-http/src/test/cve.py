import copy
import datetime as dt
import json
import pytest
import requests
import time
import uuid
from src import env, utils
from src.utils import (assert_contains, ok_response_contains,
                       response_contains, response_contains_json)

CVE_URL = '/api/cve'
cve_id = 'CVE-1999-0001'
cve_id_dne = 'CVE-3000-0001'
curr_cve_id = 'CVE-2021-0001'
update_cve_id = create_cve_id = 'CVE-1999-0008'
reserved_cve_id = 'CVE-2017-5833'
reject_cve_id = 'CVE-2000-0005'

# GET /cve
def test_get_all_cves(org_admin_headers):
    """ services api rejects requests for admin orgs """
    res = requests.get(
        f'{env.AWG_BASE_URL}{CVE_URL}/',
        headers=org_admin_headers
    )
    assert res.status_code == 403
    response_contains_json(res, 'error', 'SECRETARIAT_ONLY')

# GET /cve
def test_get_all_cves(reg_user_headers):
    """ services api rejects requests for regular users """
    res = requests.get(
        f'{env.AWG_BASE_URL}{CVE_URL}/',
        headers=reg_user_headers
    )
    assert res.status_code == 403
    response_contains_json(res, 'error', 'SECRETARIAT_ONLY')

# GET /cve
def test_get_all_cves():
    """ get all cves """
    res = requests.get(
        f'{env.AWG_BASE_URL}{CVE_URL}/',
        headers=utils.BASE_HEADERS
    )
    ok_response_contains(res, cve_id)

# GET /cve
def test_get_cve_by_time_modified():
    t_before = dt.datetime(2021, 3, 17).strftime('%Y-%m-%dT%H:%M:%S')
    t_after = dt.datetime(2021, 3, 19).strftime('%Y-%m-%dT%H:%M:%S')

    res_get_cves = requests.get(
        f'{env.AWG_BASE_URL}{CVE_URL}',
        headers=utils.BASE_HEADERS,
        params={
            'time_modified.lt': t_after,
            'time_modified.gt': t_before
        }
    )
    ok_response_contains(res_get_cves, f'CVE-{utils.CURRENT_YEAR}-')
    assert len(json.loads(res_get_cves.content.decode())['cveRecords']) == 53

# GET /cve/:id
def test_get_cve(org_admin_headers):
    """ services api rejects requests for admin orgs """
    res = requests.get(
        f'{env.AWG_BASE_URL}{CVE_URL}/{cve_id}',
        headers=org_admin_headers
    )
    assert res.status_code == 403
    response_contains_json(res, 'error', 'SECRETARIAT_ONLY')

# GET /cve/:id
def test_get_cve(reg_user_headers):
    """ services api rejects requests for regular users """
    res = requests.get(
        f'{env.AWG_BASE_URL}{CVE_URL}/{cve_id}',
        headers=reg_user_headers
    )
    assert res.status_code == 403
    response_contains_json(res, 'error', 'SECRETARIAT_ONLY')

# GET /cve/:id
def test_get_cve():
    """ the first ID from 1999 should always exist """
    res = requests.get(
        f'{env.AWG_BASE_URL}{CVE_URL}/{cve_id}',
        headers=utils.BASE_HEADERS
    )
    ok_response_contains(res, cve_id)

# GET /cve/:id
def test_get_cve_negative():
    res = requests.get(
        f'{env.AWG_BASE_URL}{CVE_URL}/{cve_id_dne}',
        headers=utils.BASE_HEADERS
    )
    assert res.status_code == 404
    response_contains_json(res, 'error', 'CVE_RECORD_DNE')

# POST /cve/:id
def test_create_cve(org_admin_headers):
    """ services api rejects requests for admin orgs """
    with open('./src/test/CVE-1999-0008_public.json') as json_file:
        data = json.load(json_file)
        res = requests.post(
            f'{env.AWG_BASE_URL}{CVE_URL}/{create_cve_id}',
            headers=org_admin_headers,
            json=data
        )
        assert res.status_code == 403
        response_contains_json(res, 'error', 'SECRETARIAT_ONLY')

# POST /cve/:id
def test_create_cve(reg_user_headers):
    """ services api rejects requests for regular users """
    with open('./src/test/CVE-1999-0008_public.json') as json_file:
        data = json.load(json_file)
        res = requests.post(
            f'{env.AWG_BASE_URL}{CVE_URL}/{create_cve_id}',
            headers=reg_user_headers,
            json=data
        )
        assert res.status_code == 403
        response_contains_json(res, 'error', 'SECRETARIAT_ONLY')

# POST /cve/:id
# TODO: Must be tested when existent CVE IDs in the RESERVED state are not stored in mongodb
# def test_create_cve():
#     """ publish a cve in the PUBLIC state """
#     with open('./src/test/CVE-1999-0008_public.json') as json_file:
#         data = json.load(json_file)
#         res = requests.post(
#             f'{env.AWG_BASE_URL}{CVE_URL}/{create_cve_id}',
#             headers=utils.BASE_HEADERS,
#             json=data
#         )
#         print(res.content.decode())
#         ok_response_contains(res, create_cve_id)

# POST /cve/:id
def test_create_cve_mismatch():
    """ the cve id in the json body does not match the cve id in the path parameter """
    with open('./src/test/CVE-1999-0008_public.json') as json_file:
        data = json.load(json_file)
        res = requests.post(
            f'{env.AWG_BASE_URL}{CVE_URL}/{curr_cve_id}',
            headers=utils.BASE_HEADERS,
            json=data
        )
        assert res.status_code == 400
        response_contains_json(res, 'error', 'CVEID_MISMATCH')

# POST /cve/:id
def test_create_cve_reserved_state():
    """ the cve record cannot be created in the RESERVED state """
    with open('./src/test/CVE-2017-5833_reserved.json') as json_file:
        data = json.load(json_file)
        res = requests.post(
            f'{env.AWG_BASE_URL}{CVE_URL}/{reserved_cve_id}',
            headers=utils.BASE_HEADERS,
            json=data
        )
        assert res.status_code == 400
        response_contains_json(res, 'error', 'CVE_UNSUPPORTED_RECORD_STATE')

# POST /cve/:id
def test_create_nonexistent_cveid():
    """ the cve record cannot be created because the CVE ID doesn't exist """
    with open('./src/test/CVE-3000-0001_nonexistent.json') as json_file:
        data = json.load(json_file)
        res = requests.post(
            f'{env.AWG_BASE_URL}{CVE_URL}/{cve_id_dne}',
            headers=utils.BASE_HEADERS,
            json=data
        )
        print(res.content.decode())
        assert res.status_code == 403
        response_contains_json(res, 'error', 'CVEID_DNE')

# POST /cve/:id
def test_create_existent_cve():
    """ the cve record cannot be created because it already exists """
    with open('./src/test/CVE-1999-0008_public.json') as json_file:
        data = json.load(json_file)
        res = requests.post(
            f'{env.AWG_BASE_URL}{CVE_URL}/{create_cve_id}',
            headers=utils.BASE_HEADERS,
            json=data
        )
        print(res.content.decode())
        assert res.status_code == 400
        response_contains_json(res, 'error', 'CVE_RECORD_EXISTS')

# PUT /cve/:id
def test_update_cve_record(org_admin_headers):
    """ services api rejects requests for admin orgs """
    with open('./src/test/CVE-1999-0008_public.json') as json_file:
        data = json.load(json_file)
        res = requests.put(
            f'{env.AWG_BASE_URL}{CVE_URL}/{update_cve_id}',
            headers=org_admin_headers,
            json=data
        )
        assert res.status_code == 403
        response_contains_json(res, 'error', 'SECRETARIAT_ONLY')

# PUT /cve/:id
def test_update_cve_record(reg_user_headers):
    """ services api rejects requests for admin orgs """
    with open('./src/test/CVE-1999-0008_public.json') as json_file:
        data = json.load(json_file)
        res = requests.put(
            f'{env.AWG_BASE_URL}{CVE_URL}/{update_cve_id}',
            headers=reg_user_headers,
            json=data
        )
        assert res.status_code == 403
        response_contains_json(res, 'error', 'SECRETARIAT_ONLY')

# PUT /cve/:id
def test_update_cve_record():
    with open('./src/test/CVE-2021-0001_public.json') as json_file:
        data = json.load(json_file)
        res = requests.put(
            f'{env.AWG_BASE_URL}{CVE_URL}/{curr_cve_id}',
            headers=utils.BASE_HEADERS,
            json=data
        )
        ok_response_contains(res, curr_cve_id)

# PUT /cve/:id
def test_update_cve_mismatch():
    """ the cve id in the json body does not match the cve id in the path parameter """
    with open('./src/test/CVE-1999-0008_public.json') as json_file:
        data = json.load(json_file)
        res = requests.put(
            f'{env.AWG_BASE_URL}{CVE_URL}/{curr_cve_id}',
            headers=utils.BASE_HEADERS,
            json=data
        )
        assert res.status_code == 400
        response_contains_json(res, 'error', 'CVEID_MISMATCH')

# PUT /cve/:id
def test_update_cve_reserved_state():
    """ the cve id in the json body does not match the cve id in the path parameter """
    with open('./src/test/CVE-2017-5833_reserved.json') as json_file:
        data = json.load(json_file)
        res = requests.put(
            f'{env.AWG_BASE_URL}{CVE_URL}/{reserved_cve_id}',
            headers=utils.BASE_HEADERS,
            json=data
        )
        assert res.status_code == 400
        response_contains_json(res, 'error', 'CVE_UNSUPPORTED_RECORD_STATE')

# PUT /cve/:id
def test_update_nonexistent_cveid():
    """ the cve record cannot be updated because the CVE ID doesn't exist """
    with open('./src/test/CVE-3000-0001_nonexistent.json') as json_file:
        data = json.load(json_file)
        res = requests.put(
            f'{env.AWG_BASE_URL}{CVE_URL}/{cve_id_dne}',
            headers=utils.BASE_HEADERS,
            json=data
        )
        print(res.content.decode())
        assert res.status_code == 403
        response_contains_json(res, 'error', 'CVEID_DNE')

# PUT /cve/:id
# TODO: Must be tested when existent CVE IDs in the RESERVED state are not stored in mongodb
# def test_update_nonexistent_cve():
#     """ the cve record cannot be updated because it doesn't exist """
#     with open('./src/test/CVE-2000-0005_reject.json') as json_file:
#         data = json.load(json_file)
#         res = requests.put(
#             f'{env.AWG_BASE_URL}{CVE_URL}/{reject_cve_id}',
#             headers=utils.BASE_HEADERS,
#             json=data
#         )
#         print(res.content.decode())
#         assert res.status_code == 403
#         response_contains_json(res, 'error', 'CVE_RECORD_DNE')

